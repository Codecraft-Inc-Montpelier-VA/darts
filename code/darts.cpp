/*
 * DO NOT EDIT THIS FILE!
 * THIS FILE IS AUTOMATICALLY GENERATED FROM A LITERATE PROGRAM SOURCE FILE.
 */
/*

 * Copyright (c) 2003 - 2021 Codecraft, Inc.
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 * 
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */
/*
 *++
 * Project:
 *   +darts+ -- a test program for coroutines and ncurses.  <by Cary WR Campbell>
 *
 * Module:
 *   +darts+ executable for macOS.
 *--
 */
/*
 * Configuration
 */
#define MAX_DARTS 3000
//#define SHOW_LATENCY_HISTOGRAM
//#define SHOW_TRANSIT_TIME_HISTOGRAM
/*
 * Include files
 */
#include <iostream>
#include <curses.h>
#include <sys/time.h>
#include "sccorlib.h"
#if defined (SHOW_LATENCY_HISTOGRAM) || defined (SHOW_TRANSIT_TIME_HISTOGRAM)
#include "histospt.h"              
#endif 
using namespace std ;
/*
 * Constants
 */
int ncols, nrows ;
#ifdef SHOW_LATENCY_HISTOGRAM
 TimeIntervalHistogram  itHistCR( "coresume round-trip times (us)",
                                  0L, 250, 40 ) ; // 0 - 10 ms
#endif 
#ifdef SHOW_TRANSIT_TIME_HISTOGRAM
 TimeIntervalHistogram  itHistTT( "screen transit times (us)",
                                  0L, 125000, 40 ) ; // 0 - 5000 ms
#endif 
/*
 * Variables
 */
WINDOW *w ;
char roundtripCounterOutputString[80] ; 
char instancesAtStopOutputString[80] ;
volatile bool orderlyStop ;
volatile bool panicStop ;
volatile bool withPacing ;
volatile int downArrowsInstanceId ;
volatile int leftArrowsInstanceId ;
volatile int leftXsInstanceId ;
volatile int rightArrowsInstanceId ;
volatile int upArrowsInstanceId ;
volatile int instancesActiveAtStop ;
/*
 * Forward References
 */
int  kbhit( void ) ;
void userInterface( void ) ;
void roundtripCounter( void ) ;
void downArrows( chtype color, int instanceId ) ;
void leftArrows( chtype color, int instanceId ) ;
void rightArrows( chtype color, int instanceId ) ;
void upArrows( chtype color, int instanceId ) ;
void leftXs( chtype color, int instanceId ) ;
/*
 * darts main routine
 */
int   main ( int argc, char *argv[] )
{
   orderlyStop               = false ;
   panicStop                 = false ;
   withPacing                = true ;
   downArrowsInstanceId      = 0 ;
   leftArrowsInstanceId      = 0 ;
   leftXsInstanceId          = 0 ;
   rightArrowsInstanceId     = 0 ;
   upArrowsInstanceId        = 0 ;
   srandom( 1 ) ;
   w = initscr() ;
   start_color() ; cbreak() ; noecho() ; leaveok( w, TRUE ) ; nonl() ;
   use_default_colors() ;
   init_pair( 1, short(COLOR_BLUE    | A_BOLD), short(-1) ) ;
   init_pair( 2, short(COLOR_RED     | A_BOLD), short(-1) ) ;
   init_pair( 3, short(COLOR_GREEN   | A_BOLD), short(-1) ) ;
   init_pair( 4, short(COLOR_YELLOW  | A_BOLD), short(-1) ) ;
   init_pair( 5, short(COLOR_MAGENTA | A_BOLD), short(-1) ) ;
   init_pair( 6, short(COLOR_CYAN    | A_BOLD), short(-1) ) ;
   init_pair( 7, short(COLOR_BLACK   | A_BOLD), short(-1) ) ;
   #define COLOR_COUNT 7
   cbreak() ;
   getmaxyx( w, nrows, ncols ) ;
   int old_visibility ;
   old_visibility = curs_set( 0 ) ;
   clear() ;
   refresh() ;
   cobegin( 2,                                                       // <1>
              roundtripCounter, 0,                                   // <2>
              userInterface,    0                                    // <2>
          ) ;
   curs_set( old_visibility ) ;
   nocbreak() ; echo() ;
   endwin() ;
   cout << roundtripCounterOutputString << endl << '\r' ;
   cout << instancesAtStopOutputString  << endl ;
   #ifdef SHOW_LATENCY_HISTOGRAM
   itHistCR.show( false ) ;                                          // <1>
   itHistCR.reset() ;                                                // <2>
   #endif 

   #ifdef SHOW_TRANSIT_TIME_HISTOGRAM
   itHistTT.show( false ) ;  
   itHistTT.reset() ; 
   #endif 

   return( 0 ) ;
}
/*
 * darts Coroutines
 */
void rightArrows( chtype color, int instanceId )
{
   while ( !orderlyStop && !panicStop && instanceId <= rightArrowsInstanceId ) {
      int row = random() % nrows ;

      for ( int column = 0; !panicStop && column < ncols; column++ ) {
         wmove( w, row, column ) ;
         wechochar( w, ACS_RARROW | color ) ;
         if ( withPacing ) {
            wait( 1000 / ncols ) ; // ms
         } else {
            coresume() ;
         }
      }
      for ( int column = ncols - 1; !panicStop && column >= 0; column-- ) {
         wmove( w, row, column ) ;
         wechochar( w, ' ' ) ;
         if ( withPacing ) {
            wait( 1000 / ncols ) ; // ms
         } else {
            coresume() ;
         }
      }
   }
}
void leftArrows( chtype color, int instanceId )
{
   while ( !orderlyStop && !panicStop && instanceId <= leftArrowsInstanceId ) {
      int row = random() % nrows ;

      for ( int column = ncols - 1; !panicStop && column >= 0; column-- ) {
         wmove( w, row, column ) ;
         wechochar( w, ACS_LARROW | color ) ;
         if ( withPacing ) {
            wait( 1000 / ncols ) ; // ms
         } else {
            coresume() ;
         }
      }
      for ( int column = 0; !panicStop && column < ncols; column++ ) {
         wmove( w, row, column ) ;
         wechochar( w, ' ' ) ;
         if ( withPacing ) {
            wait( 1000 / ncols ) ; // ms
         } else {
            coresume() ;
         }
      }
   }
}                                                           
void upArrows( chtype color, int instanceId )
{
   while ( !orderlyStop && !panicStop && instanceId <= upArrowsInstanceId ) {
      int column = random() % ncols ;

      for ( int row = nrows - 1; !panicStop && row >= 0; row-- ) {
         wmove( w, row, column ) ;
         wechochar( w, ACS_UARROW | color ) ;
         if ( withPacing ) {
            wait( 1000 / nrows ) ; // ms
         } else {
            coresume() ;
         }
      }
      for ( int row = 0; !panicStop && row < nrows; row++ ) {
         wmove( w, row, column ) ;
         wechochar( w, ' ' ) ;
         if ( withPacing ) {
            wait( 1000 / nrows ) ; // ms
         } else {
            coresume() ;
         }
      }
   }
}
void downArrows( chtype color, int instanceId ) 
{
   while ( !orderlyStop && !panicStop && instanceId <= downArrowsInstanceId ) {
      int column = random() % ncols ;

      for ( int row = 0; !panicStop && row < nrows; row++ ) {
         wmove( w, row, column ) ;
         wechochar( w, /*ACS_DARROW*/ 'v' | color ) ;               // <1>
         if ( withPacing ) {
            wait( 1000 / nrows ) ; // ms
         } else {
            coresume() ;
         }
      }
      for ( int row = nrows - 1; !panicStop && row >= 0; row-- ) {
         wmove( w, row, column ) ;
         wechochar( w, ' ' ) ;
         if ( withPacing ) {
            wait( 1000 / nrows ) ; // ms
         } else {
            coresume() ;
         }
      }
   }
}
void leftXs( chtype color, int instanceId )
{
   while ( !orderlyStop && !panicStop && instanceId <= leftXsInstanceId ) {
      #ifdef SHOW_TRANSIT_TIME_HISTOGRAM
      itHistTT.tally() ;
      #endif 
      int row = random() % nrows ;

      for ( int column = ncols - 1; !panicStop && column >= 0; column-- ) {
         wmove( w, row, column ) ;
         wechochar( w, 'x' | color ) ;
         if ( withPacing ) {
            wait( 1000 / ncols ) ; // ms
         } else {
            coresume() ;
         }
      }
      #ifdef SHOW_TRANSIT_TIME_HISTOGRAM
      itHistTT.tally() ;
      #endif 
      for ( int column = 0; !panicStop && column < ncols; column++ ) {
         wmove( w, row, column ) ;
         wechochar( w, ' ' ) ;
         if ( withPacing ) {
            wait( 1000 / ncols ) ; // ms
         } else {
            coresume() ;
         }
      }
   }
}                                                           
#define CHECK_KB_FREQUENCY 10
void userInterface( void )
{
   char   c ;
   chtype randomColor ;
   int    loopCount = 0 ;

   while ( !orderlyStop && !panicStop ) {
      if ( ++loopCount >= CHECK_KB_FREQUENCY && kbhit() ) {
         loopCount = 0 ;
         c = getch() ;
         switch ( c ) {
            case '>':
               {
                  if ( getCoroutineCount() <= MAX_DARTS ) {
                     randomColor = COLOR_PAIR( random() % COLOR_COUNT ) ;
                     invoke( (COROUTINE)rightArrows, 2, randomColor, 
                             ++rightArrowsInstanceId ) ;
                  }
               }
               break ;
            case '.':
               {
                  if ( rightArrowsInstanceId > 0 ) {
                     --rightArrowsInstanceId ;
                  } else {
                     rightArrowsInstanceId = 0 ;                     // <1>
                  }
               }
               break ;
            case '<':
               {
                  if ( getCoroutineCount() <= MAX_DARTS ) {
                     randomColor = COLOR_PAIR( random() % COLOR_COUNT ) ;
                     invoke( (COROUTINE)leftArrows, 2, randomColor, 
                             ++leftArrowsInstanceId ) ;
                  }
               }
               break ;
            case ',':
               {
                  if ( leftArrowsInstanceId > 0 ) {
                     --leftArrowsInstanceId ;
                  } else {
                     leftArrowsInstanceId = 0 ;
                  }
               }
               break ;
            case 'A':
               {
                  if ( getCoroutineCount() <= MAX_DARTS ) {
                     randomColor  = COLOR_PAIR( random() % COLOR_COUNT ) ;
                     invoke( (COROUTINE)upArrows, 2, randomColor, 
                             ++upArrowsInstanceId ) ;
                  }
               }
               break ;
            case 'a':
               {
                  if ( upArrowsInstanceId > 0 ) {
                     --upArrowsInstanceId ;
                  } else {
                     upArrowsInstanceId = 0 ;
                  }
               }
               break ;
            case 'X':
               {
                  if ( getCoroutineCount() <= MAX_DARTS ) {
                     randomColor  = COLOR_PAIR( random() % COLOR_COUNT ) ;
                     invoke( (COROUTINE)leftXs, 2, randomColor, 
                             ++leftXsInstanceId ) ;
                  }
               }
               break ;
            case 'x':
               {
                  if ( leftXsInstanceId > 0 ) {
                     --leftXsInstanceId ;
                  } else {
                     leftXsInstanceId = 0 ;
                  }
               }
               break ;
            case 'V':
               {
                  if ( getCoroutineCount() <= MAX_DARTS ) {
                     randomColor  = COLOR_PAIR( random() % COLOR_COUNT ) ;
                     invoke( (COROUTINE)downArrows, 2, randomColor, 
                             ++downArrowsInstanceId ) ;
                  }
               }
               break ;
            case 'v':
               {
                  if ( downArrowsInstanceId > 0 ) {
                     --downArrowsInstanceId ;
                  } else {
                     downArrowsInstanceId = 0 ;
                  }
               }
               break ;
            case 'C':
               {
                  for ( int i = 0; i < 25; i++ ) {
                     if ( getCoroutineCount() <= MAX_DARTS ) {
                        randomColor = COLOR_PAIR( random() % COLOR_COUNT ) ;
                        invoke( (COROUTINE)rightArrows, 2, randomColor, 
                                ++rightArrowsInstanceId ) ;
                        coresume() ;
                     }
                     if ( getCoroutineCount() <= MAX_DARTS ) {
                        randomColor = COLOR_PAIR(random() % COLOR_COUNT) ;
                        invoke( (COROUTINE)leftArrows, 2, randomColor, 
                                ++leftArrowsInstanceId ) ;
                        coresume() ;
                     }
                     if ( getCoroutineCount() <= MAX_DARTS ) {
                        randomColor = COLOR_PAIR(random() % COLOR_COUNT) ;
                        invoke( (COROUTINE)upArrows, 2, randomColor, 
                                ++upArrowsInstanceId ) ;
                        coresume() ;
                     }
                     if ( getCoroutineCount() <= MAX_DARTS ) {
                        randomColor = COLOR_PAIR(random() % COLOR_COUNT) ;
                        invoke( (COROUTINE)downArrows, 2, randomColor, 
                                ++downArrowsInstanceId ) ;
                        coresume() ;
                     }
                  }
               }
               break ;
            case 'c':                              
               {
                  if ( rightArrowsInstanceId > 25 ) {
                     rightArrowsInstanceId -= 25 ;
                  } else {
                     rightArrowsInstanceId = 0 ;
                  }
                  if ( leftArrowsInstanceId > 25 ) {
                     leftArrowsInstanceId -= 25 ;
                  } else {
                     leftArrowsInstanceId = 0 ;
                  }
                  if ( upArrowsInstanceId > 25 ) {
                     upArrowsInstanceId -= 25 ;
                  } else {
                     upArrowsInstanceId = 0 ;
                  }
                  if ( downArrowsInstanceId > 25 ) {
                     downArrowsInstanceId -= 25 ;
                  } else {
                     downArrowsInstanceId = 0 ;
                  }
               }
               break ;
            case 'M':
               {
                  for ( int i = 0; i < 250; i++ ) {
                     if ( getCoroutineCount() <= MAX_DARTS ) {
                        randomColor = COLOR_PAIR( random() % COLOR_COUNT ) ;
                        invoke( (COROUTINE)rightArrows, 2, randomColor, 
                                ++rightArrowsInstanceId ) ;
                        coresume() ;
                     }
                     if ( getCoroutineCount() <= MAX_DARTS ) {
                        randomColor = COLOR_PAIR(random() % COLOR_COUNT) ;
                        invoke( (COROUTINE)leftArrows, 2, randomColor, 
                                ++leftArrowsInstanceId ) ;
                        coresume() ;
                     }
                     if ( getCoroutineCount() <= MAX_DARTS ) {
                        randomColor = COLOR_PAIR(random() % COLOR_COUNT) ;
                        invoke( (COROUTINE)upArrows, 2, randomColor, 
                                ++upArrowsInstanceId) ;
                        coresume() ;
                     }
                     if ( getCoroutineCount() <= MAX_DARTS ) {
                        randomColor = COLOR_PAIR(random() % COLOR_COUNT) ;
                        invoke( (COROUTINE)downArrows, 2, randomColor, 
                                ++downArrowsInstanceId ) ;
                        coresume() ;
                     }
                  }
               }
               break ;
            case 'm':                              
               {
                  if ( rightArrowsInstanceId > 250 ) {
                     rightArrowsInstanceId -= 250 ;
                  } else {
                     rightArrowsInstanceId = 0 ;
                  }
                  if ( leftArrowsInstanceId > 250 ) {
                     leftArrowsInstanceId -= 250 ;
                  } else {
                     leftArrowsInstanceId = 0 ;
                  }
                  if ( upArrowsInstanceId > 250 ) {
                     upArrowsInstanceId -= 250 ;
                  } else {
                     upArrowsInstanceId = 0 ;
                  }
                  if ( downArrowsInstanceId > 250 ) {
                     downArrowsInstanceId -= 250 ;
                  } else {
                     downArrowsInstanceId = 0 ;
                  }
               }
               break ;
            case 'W':
               withPacing = true ;
               break ;
            case 'w':
               withPacing = false ;
               break ;
            case 'Q':
               instancesActiveAtStop = getCoroutineCount() ;
               orderlyStop = true ;
               break ;
            case 'q':
               instancesActiveAtStop = getCoroutineCount() ;
               panicStop = true ;
               break ;
         }
      }
      coresume() ;
   }
}
void roundtripCounter( void )
{
   unsigned int coresumeCount = 0 ;
   unsigned int startTime ;
   unsigned int endTime ;
   struct timeval tv ;

   gettimeofday( &tv, (struct timezone *)NULL ) ;
   startTime = tv.tv_sec * 1000 + tv.tv_usec / 1000 ;

   bool otherCoroutinesComplete = false ;
   while ( !otherCoroutinesComplete && !panicStop ) {
      #ifdef SHOW_LATENCY_HISTOGRAM
      itHistCR.tally() ;
      #endif 
      coresumeCount++ ;
      coresume() ;
      if ( orderlyStop && getCoroutineCount() < 2 ) {
         otherCoroutinesComplete = true ; 
      }
   }

   gettimeofday( &tv, (struct timezone *)NULL ) ;
   endTime = tv.tv_sec * 1000 + tv.tv_usec / 1000 ;

   when( getCoroutineCount() < 2 ) {                                 // <1>
      sprintf( roundtripCounterOutputString,                         // <2>
               ">>> coresume cycle count: %u (%u / sec).",
               coresumeCount,
               coresumeCount / ( ( endTime - startTime ) / 1000 ) ) ;
      sprintf( instancesAtStopOutputString,                          // <3>
               ">>>  darts count at stop: %u.", instancesActiveAtStop - 2 ) ;
   }
}

